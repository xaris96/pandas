# engine/_py_processors.py
# Copyright (C) 2010-2025 the SQLAlchemy authors and contributors
# <see AUTHORS file>
# Copyright (C) 2010 Gaetan de Menten gdementen@gmail.com
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

"""defines generic type conversion functions, as used in bind and result
processors.

They all share one common characteristic: None is passed through unchanged.

"""

from __future__ import annotations

import datetime
from datetime import (
    date as date_cls,
    datetime as datetime_cls,
    time as time_cls,
)
from decimal import Decimal
import typing
from typing import (
    Any,
    Optional,
    Type,
    TypeVar,
    Union,
)

from collections.abc import Callable

_DT = TypeVar(
    "_DT", bound=Union[datetime.datetime, datetime.time, datetime.date]
)


def str_to_datetime_processor_factory(
    regexp: typing.Pattern[str], type_: Callable[..., _DT]
) -> Callable[[str | None], _DT | None]:
    rmatch = regexp.match
    # Even on python2.6 datetime.strptime is both slower than this code
    # and it does not support microseconds.
    has_named_groups = bool(regexp.groupindex)

    def process(value: str | None) -> _DT | None:
        if value is None:
            return None
        else:
            try:
                m = rmatch(value)
            except TypeError as err:
                raise ValueError(
                    "Couldn't parse %s string '%r' "
                    "- value is not a string." % (type_.__name__, value)
                ) from err

            if m is None:
                raise ValueError(
                    "Couldn't parse %s string: "
                    "'%s'" % (type_.__name__, value)
                )
            if has_named_groups:
                groups = m.groupdict(0)
                return type_(
                    **dict(
                        list(
                            zip(
                                iter(groups.keys()),
                                list(map(int, iter(groups.values()))),
                            )
                        )
                    )
                )
            else:
                return type_(*list(map(int, m.groups(0))))

    return process


def to_decimal_processor_factory(
    target_class: type[Decimal], scale: int
) -> Callable[[float | None], Decimal | None]:
    fstring = "%%.%df" % scale

    def process(value: float | None) -> Decimal | None:
        if value is None:
            return None
        else:
            return target_class(fstring % value)

    return process


def to_float(value: int | float | None) -> float | None:
    if value is None:
        return None
    else:
        return float(value)


def to_str(value: Any | None) -> str | None:
    if value is None:
        return None
    else:
        return str(value)


def int_to_boolean(value: int | None) -> bool | None:
    if value is None:
        return None
    else:
        return bool(value)


def str_to_datetime(value: str | None) -> datetime.datetime | None:
    if value is not None:
        dt_value = datetime_cls.fromisoformat(value)
    else:
        dt_value = None
    return dt_value


def str_to_time(value: str | None) -> datetime.time | None:
    if value is not None:
        dt_value = time_cls.fromisoformat(value)
    else:
        dt_value = None
    return dt_value


def str_to_date(value: str | None) -> datetime.date | None:
    if value is not None:
        dt_value = date_cls.fromisoformat(value)
    else:
        dt_value = None
    return dt_value
